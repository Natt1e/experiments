--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
@@ -32,13 +32,13 @@
      * Let's start with sizable but not huge buffer, will grow as necessary
      */
     final static int MIN_SEGMENT_LEN = 1000;
-    
+
     /**
      * Let's limit maximum segment length to something sensible
      * like 256k
      */
     final static int MAX_SEGMENT_LEN = 0x40000;
-    
+
     /*
     /**********************************************************
     /* Configuration:
@@ -222,9 +222,9 @@
             clearSegments();
         }
         _currentSize = 0;
-        
+
     }
-    
+
     /**
      * Helper method used to find a buffer to use, ideally one
      * recycled earlier.
@@ -294,7 +294,7 @@
         if (_resultString != null) return false;
         return true;
     }
-    
+
     public char[] getTextBuffer()
     {
         // Are we just using shared input buffer?
@@ -304,7 +304,16 @@
             return (_resultArray = _resultString.toCharArray());
         }
         // Nope; but does it fit in just one segment?
-        if (!_hasSegments)  return _currentSegment;
+        if (!_hasSegments) {
+            /* 14-Jan-2016, tatu: As per #182 we must never return `null` for
+             *    empty buffer, and for empty content should return an empty
+             *    array (not an internal reusable segment buffer).
+             */
+            if (_currentSize < 1) {
+                return NO_CHARS;
+            }
+            return (_currentSegment == null) ? NO_CHARS : _currentSegment;
+        }
         // Nope, need to have/create a non-segmented array and return it
         return contentsAsArray();
     }
@@ -332,7 +341,7 @@
                     // But first, let's see if we have just one buffer
                     int segLen = _segmentSize;
                     int currLen = _currentSize;
-                    
+
                     if (segLen == 0) { // yup
                         _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen);
                     } else { // no, need to combine
@@ -353,7 +362,7 @@
         }
         return _resultString;
     }
- 
+
     public char[] contentsAsArray() {
         char[] result = _resultArray;
         if (result == null) {
@@ -436,7 +445,7 @@
         // Room in current segment?
         char[] curr = _currentSegment;
         int max = curr.length - _currentSize;
-            
+
         if (max >= len) {
             System.arraycopy(c, start, curr, _currentSize, len);
             _currentSize += len;
@@ -565,7 +574,7 @@
         _resultString = str;
         return str;
     }
-    
+
     public char[] finishCurrentSegment() {
         if (_segments == null) {
             _segments = new ArrayList<char[]>();
@@ -610,7 +619,7 @@
      * Method called to expand size of the current segment, to
      * accommodate for more contiguous content. Usually only
      * used when parsing tokens like names if even then.
-     * 
+     *
      * @param minSize Required minimum strength of the current segment
      *
      * @since 2.4.0
@@ -682,7 +691,7 @@
         _segmentSize += curr.length;
         _currentSize = 0;
         int oldLen = curr.length;
-        
+
         // Let's grow segments by 50% minimum
         int newLen = oldLen + (oldLen >> 1);
         if (newLen < MIN_SEGMENT_LEN) {
